'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var React = require('react');
var React__default = _interopDefault(React);
var reactThreeFiber = require('react-three-fiber');
var OrbitControls$1 = require('three/examples/jsm/controls/OrbitControls');
var mergeRefs = _interopDefault(require('react-merge-refs'));
var TrackballControls$1 = require('three/examples/jsm/controls/TrackballControls');
var DeviceOrientationControls$1 = require('three/examples/jsm/controls/DeviceOrientationControls');
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var TransformControls$1 = require('three/examples/jsm/controls/TransformControls');
var pick = _interopDefault(require('lodash.pick'));
var omit = _interopDefault(require('lodash.omit'));
var FlyControls$1 = require('three/examples/jsm/controls/FlyControls');
var THREE = require('three');
var _construct = _interopDefault(require('@babel/runtime/helpers/construct'));
var postprocessing = require('postprocessing');
var troikaThreeText = require('troika-three-text');
var ReactDOM = _interopDefault(require('react-dom'));
var StatsImpl = _interopDefault(require('stats.js'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var _defineProperty = _interopDefault(require('@babel/runtime/helpers/defineProperty'));
var Sky$1 = require('three/examples/jsm/objects/Sky');
var Reflector$1 = require('three/examples/jsm/objects/Reflector');
var LineGeometry = require('three/examples/jsm/lines/LineGeometry');
var LineMaterial = require('three/examples/jsm/lines/LineMaterial');
var Line2 = require('three/examples/jsm/lines/Line2');
var DRACOLoader = require('three/examples/jsm/loaders/DRACOLoader');
var GLTFLoader = require('three/examples/jsm/loaders/GLTFLoader');

reactThreeFiber.extend({
  OrbitControlsImpl: OrbitControls$1.OrbitControls
});
var OrbitControls = /*#__PURE__*/React.forwardRef(function (props, ref) {
  if (props === void 0) {
    props = {
      enableDamping: true
    };
  }

  var controls = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl,
      invalidate = _useThree.invalidate;

  reactThreeFiber.useFrame(function () {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  React.useEffect(function () {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return function () {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React__default.createElement("orbitControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement],
    enableDamping: true
  }, props));
});

reactThreeFiber.extend({
  MapControlsImpl: OrbitControls$1.MapControls
});
var MapControls = /*#__PURE__*/React.forwardRef(function (props, ref) {
  if (props === void 0) {
    props = {
      enableDamping: true
    };
  }

  var controls = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl,
      invalidate = _useThree.invalidate;

  reactThreeFiber.useFrame(function () {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  React.useEffect(function () {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return function () {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React__default.createElement("mapControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement],
    enableDamping: true
  }, props));
});

reactThreeFiber.extend({
  TrackballControlsImpl: TrackballControls$1.TrackballControls
});
var TrackballControls = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var controls = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl,
      invalidate = _useThree.invalidate;

  reactThreeFiber.useFrame(function () {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  React.useEffect(function () {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return function () {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React__default.createElement("trackballControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement]
  }, props));
});

reactThreeFiber.extend({
  DeviceOrientationControlsImp: DeviceOrientationControls$1.DeviceOrientationControls
});
var DeviceOrientationControls = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var controls = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera;

  reactThreeFiber.useFrame(function () {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update();
  });
  React.useEffect(function () {
    var currentControl = controls.current;
    currentControl == null ? void 0 : currentControl.connect();
    return function () {
      return currentControl == null ? void 0 : currentControl.dispose();
    };
  });
  return /*#__PURE__*/React__default.createElement("deviceOrientationControlsImp", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera]
  }, props));
});

reactThreeFiber.extend({
  TransformControlsImpl: TransformControls$1.TransformControls
});
var TransformControls = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["children"]);

  var transformOnlyPropNames = ['enabled', 'axis', 'mode', 'translationSnap', 'rotationSnap', 'scaleSnap', 'space', 'size', 'dragging', 'showX', 'showY', 'showZ'];
  var transformProps = pick(props, transformOnlyPropNames);
  var objectProps = omit(props, transformOnlyPropNames);
  var controls = React.useRef();
  var group = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl,
      invalidate = _useThree.invalidate;

  React.useLayoutEffect(function () {
    var _controls$current;

    return void ((_controls$current = controls.current) == null ? void 0 : _controls$current.attach(group.current));
  }, [children]);
  React.useEffect(function () {
    var _controls$current2;

    (_controls$current2 = controls.current) == null ? void 0 : _controls$current2.addEventListener('change', invalidate);
    return function () {
      var _controls$current3;

      return (_controls$current3 = controls.current) == null ? void 0 : _controls$current3.removeEventListener('change', invalidate);
    };
  }, [controls.current]);
  return /*#__PURE__*/React__default.createElement(React__default.Fragment, null, /*#__PURE__*/React__default.createElement("transformControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement]
  }, transformProps)), /*#__PURE__*/React__default.createElement("group", _extends({
    ref: group
  }, objectProps), children));
});

reactThreeFiber.extend({
  FlyControlsImpl: FlyControls$1.FlyControls
});
var FlyControls = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var controls = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera,
      gl = _useThree.gl;

  reactThreeFiber.useFrame(function (state, delta) {
    var _controls$current;

    return (_controls$current = controls.current) == null ? void 0 : _controls$current.update(delta);
  });
  return /*#__PURE__*/React__default.createElement("flyControlsImpl", _extends({
    ref: mergeRefs([controls, ref]),
    args: [camera, gl.domElement]
  }, props));
});

var Detailed = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      distances = _ref.distances,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "distances"]);

  var lod = reactThreeFiber.useUpdate(function (lod) {
    lod.levels.length = 0;
    lod.children.forEach(function (object, index) {
      return lod.levels.push({
        object: object,
        distance: distances[index]
      });
    });
  }, []);
  reactThreeFiber.useFrame(function (state) {
    var _lod$current;

    return (_lod$current = lod.current) == null ? void 0 : _lod$current.update(state.camera);
  });
  return /*#__PURE__*/React__default.createElement("lOD", _extends({
    ref: mergeRefs([lod, ref])
  }, props), children);
});

var PositionalAudio = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var url = _ref.url,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? 1 : _ref$distance,
      _ref$loop = _ref.loop,
      loop = _ref$loop === void 0 ? true : _ref$loop,
      props = _objectWithoutPropertiesLoose(_ref, ["url", "distance", "loop"]);

  var sound = React.useRef();

  var _useThree = reactThreeFiber.useThree(),
      camera = _useThree.camera;

  var _useState = React.useState(function () {
    return new THREE.AudioListener();
  }),
      listener = _useState[0];

  var buffer = reactThreeFiber.useLoader(THREE.AudioLoader, url);
  React.useEffect(function () {
    var _sound$current, _sound$current2, _sound$current3, _sound$current4;

    (_sound$current = sound.current) == null ? void 0 : _sound$current.setBuffer(buffer);
    (_sound$current2 = sound.current) == null ? void 0 : _sound$current2.setRefDistance(distance);
    (_sound$current3 = sound.current) == null ? void 0 : _sound$current3.setLoop(loop);
    (_sound$current4 = sound.current) == null ? void 0 : _sound$current4.play();
    camera.add(listener);
    return function () {
      var _sound$current5, _sound$current6;

      camera.remove(listener);
      (_sound$current5 = sound.current) == null ? void 0 : _sound$current5.stop();
      (_sound$current6 = sound.current) == null ? void 0 : _sound$current6.disconnect();
    };
  }, []);
  return /*#__PURE__*/React__default.createElement("positionalAudio", _extends({
    ref: mergeRefs([sound, ref]),
    args: [listener]
  }, props));
});

var PerspectiveCamera = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      _ref$makeDefault = _ref.makeDefault,
      makeDefault = _ref$makeDefault === void 0 ? false : _ref$makeDefault,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "makeDefault"]);

  var _useThree = reactThreeFiber.useThree(),
      setDefaultCamera = _useThree.setDefaultCamera,
      camera = _useThree.camera,
      size = _useThree.size;

  var cameraRef = reactThreeFiber.useUpdate(function (cam) {
    cam.aspect = size.width / size.height;
    cam.updateProjectionMatrix();
  }, [size, props]);
  React.useLayoutEffect(function () {
    if (makeDefault && cameraRef.current) {
      var oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return function () {
        return setDefaultCamera(oldCam);
      };
    }
  }, []);
  return /*#__PURE__*/React__default.createElement("perspectiveCamera", _extends({
    ref: mergeRefs([cameraRef, ref])
  }, props), children);
});

var OrthographicCamera = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      _ref$makeDefault = _ref.makeDefault,
      makeDefault = _ref$makeDefault === void 0 ? false : _ref$makeDefault,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "makeDefault"]);

  var _useThree = reactThreeFiber.useThree(),
      setDefaultCamera = _useThree.setDefaultCamera,
      camera = _useThree.camera,
      size = _useThree.size;

  var cameraRef = reactThreeFiber.useUpdate(function (cam) {
    return cam.updateProjectionMatrix();
  }, [size, props]);
  React.useLayoutEffect(function () {
    if (makeDefault && cameraRef.current) {
      var oldCam = camera;
      setDefaultCamera(cameraRef.current);
      return function () {
        return setDefaultCamera(oldCam);
      };
    }
  }, []);
  return /*#__PURE__*/React__default.createElement("orthographicCamera", _extends({
    left: size.width / -2,
    right: size.width / 2,
    top: size.height / 2,
    bottom: size.height / -2,
    ref: mergeRefs([cameraRef, ref])
  }, props), children);
});

function StandardEffects(_ref) {
  var _ref$smaa = _ref.smaa,
      smaa = _ref$smaa === void 0 ? true : _ref$smaa,
      _ref$ao = _ref.ao,
      ao = _ref$ao === void 0 ? true : _ref$ao,
      _ref$bloom = _ref.bloom,
      bloom = _ref$bloom === void 0 ? true : _ref$bloom,
      _ref$edgeDetection = _ref.edgeDetection,
      edgeDetection = _ref$edgeDetection === void 0 ? 0.1 : _ref$edgeDetection,
      _ref$bloomOpacity = _ref.bloomOpacity,
      bloomOpacity = _ref$bloomOpacity === void 0 ? 1 : _ref$bloomOpacity,
      effects = _ref.effects;

  var _useThree = reactThreeFiber.useThree(),
      gl = _useThree.gl,
      scene = _useThree.scene,
      camera = _useThree.camera,
      size = _useThree.size;

  var smaaProps = reactThreeFiber.useLoader(postprocessing.SMAAImageLoader, '');
  var composer = React.useMemo(function () {
    var composer = new postprocessing.EffectComposer(gl, {
      frameBufferType: THREE.HalfFloatType
    });
    composer.addPass(new postprocessing.RenderPass(scene, camera));

    var smaaEffect = _construct(postprocessing.SMAAEffect, smaaProps);

    smaaEffect.colorEdgesMaterial.setEdgeDetectionThreshold(edgeDetection);
    var normalPass = new postprocessing.NormalPass(scene, camera);
    var ssaoEffect = new postprocessing.SSAOEffect(camera, normalPass.renderTarget.texture, _extends({
      blendFunction: postprocessing.BlendFunction.MULTIPLY,
      samples: 21,
      // May get away with less samples
      rings: 4,
      // Just make sure this isn't a multiple of samples
      distanceThreshold: 1.0,
      distanceFalloff: 0.0,
      rangeThreshold: 0.015,
      // Controls sensitivity based on camera view distance **
      rangeFalloff: 0.002,
      luminanceInfluence: 0.9,
      radius: 20,
      // Spread range
      scale: 1.0,
      // Controls intensity **
      bias: 0.05
    }, ao));
    var bloomEffect = new postprocessing.BloomEffect(_extends({
      opacity: 1,
      blendFunction: postprocessing.BlendFunction.SCREEN,
      kernelSize: postprocessing.KernelSize.VERY_LARGE,
      luminanceThreshold: 0.9,
      luminanceSmoothing: 0.07,
      height: 600
    }, bloom));
    bloomEffect.blendMode.opacity.value = bloomOpacity;
    var effectsArray = [];
    if (effects) effectsArray = effects([smaaEffect, ssaoEffect, bloomEffect]);else {
      if (smaa) effectsArray.push(smaaEffect);
      if (ao) effectsArray.push(ssaoEffect);
      if (bloom) effectsArray.push(bloomEffect);
    }

    var effectPass = _construct(postprocessing.EffectPass, [camera].concat(effectsArray));

    effectPass.renderToScreen = true;
    composer.addPass(normalPass);
    composer.addPass(effectPass);
    return composer;
  }, [camera, gl, scene, smaa, ao, bloom, edgeDetection, bloomOpacity]);
  React.useEffect(function () {
    return void composer.setSize(size.width, size.height);
  }, [composer, size]);
  React.useEffect(function () {
    return void console.warn("⚡️ StandardEffects will be removed in drei v1.0.0; use react-postprocessing instead https://github.com/react-spring/react-postprocessing");
  }, []);
  return reactThreeFiber.useFrame(function (_, delta) {
    return composer.render(delta);
  }, 1);
}

reactThreeFiber.extend({
  TextMeshImpl: troikaThreeText.Text
});
var Text = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$anchorX = _ref.anchorX,
      anchorX = _ref$anchorX === void 0 ? 'center' : _ref$anchorX,
      _ref$anchorY = _ref.anchorY,
      anchorY = _ref$anchorY === void 0 ? 'middle' : _ref$anchorY,
      children = _ref.children,
      props = _objectWithoutPropertiesLoose(_ref, ["anchorX", "anchorY", "children"]);

  var textRef = React.useRef();

  var _useState = React.useState(),
      baseMtl = _useState[0],
      setBaseMtl = _useState[1];

  var _useMemo = React.useMemo(function () {
    var n = [];
    var t = '';
    React.Children.forEach(children, function (child) {
      if (typeof child === 'string') t += child;else if (child && typeof child === 'object' && child.props.attach === 'material') {
        // Instantiate the base material and grab a reference to it, but don't assign any
        // props, and assign it as the `material`, which Troika will replace behind the scenes.
        n.push( /*#__PURE__*/React.createElement(child.type, {
          ref: setBaseMtl,
          attach: 'material'
        })); // Once the base material has been assigned, grab the resulting upgraded material,
        // and apply the original material props to that.

        if (baseMtl) {
          n.push( /*#__PURE__*/React__default.createElement("primitive", _extends({
            object: textRef.current.material
          }, child.props, {
            attach: null
          })));
        }
      } else n.push(child);
    });
    return [n, t];
  }, [children, baseMtl]),
      nodes = _useMemo[0],
      text = _useMemo[1];

  React.useLayoutEffect(function () {
    return void textRef.current.sync();
  });
  return /*#__PURE__*/React__default.createElement("textMeshImpl", _extends({
    ref: mergeRefs([textRef, ref]),
    text: text,
    anchorX: anchorX,
    anchorY: anchorY
  }, props), nodes);
});

var v1 = new THREE.Vector3();
var v2 = new THREE.Vector3();
var v3 = new THREE.Vector3();

function calculatePosition(el, camera, size) {
  var objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  objectPos.project(camera);
  var widthHalf = size.width / 2;
  var heightHalf = size.height / 2;
  return [objectPos.x * widthHalf + widthHalf, -(objectPos.y * heightHalf) + heightHalf];
}

function isObjectBehindCamera(el, camera) {
  var objectPos = v1.setFromMatrixPosition(el.matrixWorld);
  var cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
  var deltaCamObj = objectPos.sub(cameraPos);
  var camDir = camera.getWorldDirection(v3);
  return deltaCamObj.angleTo(camDir) > Math.PI / 2;
}

function objectScale(el, camera) {
  if (camera instanceof THREE.PerspectiveCamera) {
    var objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    var cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    var vFOV = camera.fov * Math.PI / 180;
    var dist = objectPos.distanceTo(cameraPos);
    return 1 / (2 * Math.tan(vFOV / 2) * dist);
  }

  if (camera instanceof THREE.OrthographicCamera) return camera.zoom;
  return 1;
}

function objectZIndex(el, camera, zIndexRange) {
  if (camera instanceof THREE.PerspectiveCamera || camera instanceof THREE.OrthographicCamera) {
    var objectPos = v1.setFromMatrixPosition(el.matrixWorld);
    var cameraPos = v2.setFromMatrixPosition(camera.matrixWorld);
    var dist = objectPos.distanceTo(cameraPos);
    var A = (zIndexRange[1] - zIndexRange[0]) / (camera.far - camera.near);
    var B = zIndexRange[1] - A * camera.far;
    return Math.round(A * dist + B);
  }

  return undefined;
}

var Html = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _portal$current;

  var children = _ref.children,
      _ref$eps = _ref.eps,
      eps = _ref$eps === void 0 ? 0.001 : _ref$eps,
      style = _ref.style,
      className = _ref.className,
      prepend = _ref.prepend,
      center = _ref.center,
      fullscreen = _ref.fullscreen,
      portal = _ref.portal,
      scaleFactor = _ref.scaleFactor,
      _ref$zIndexRange = _ref.zIndexRange,
      zIndexRange = _ref$zIndexRange === void 0 ? [16777271, 0] : _ref$zIndexRange,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "eps", "style", "className", "prepend", "center", "fullscreen", "portal", "scaleFactor", "zIndexRange"]);

  var _useThree = reactThreeFiber.useThree(),
      gl = _useThree.gl,
      scene = _useThree.scene,
      camera = _useThree.camera,
      size = _useThree.size;

  var _useState = React.useState(function () {
    return document.createElement('div');
  }),
      el = _useState[0];

  var group = React.useRef(null);
  var old = React.useRef([0, 0]);
  var target = (_portal$current = portal == null ? void 0 : portal.current) != null ? _portal$current : gl.domElement.parentNode;
  React.useEffect(function () {
    if (group.current) {
      scene.updateMatrixWorld();
      var vec = calculatePosition(group.current, camera, size);
      el.style.cssText = "position:absolute;top:0;left:0;transform:translate3d(" + vec[0] + "px," + vec[1] + "px,0);transform-origin:0 0;";

      if (target) {
        if (prepend) target.prepend(el);else target.appendChild(el);
      }

      return function () {
        if (target) target.removeChild(el);
        ReactDOM.unmountComponentAtNode(el);
      };
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [target]);
  var styles = React.useMemo(function () {
    return _extends({
      position: 'absolute',
      transform: center ? 'translate3d(-50%,-50%,0)' : 'none'
    }, fullscreen && {
      top: -size.height / 2,
      left: -size.width / 2,
      width: size.width,
      height: size.height
    }, style);
  }, [style, center, fullscreen, size]);
  React.useEffect(function () {
    return void ReactDOM.render( /*#__PURE__*/React__default.createElement("div", {
      ref: ref,
      style: styles,
      className: className,
      children: children
    }), el);
  });
  reactThreeFiber.useFrame(function () {
    if (group.current) {
      var vec = calculatePosition(group.current, camera, size);

      if (Math.abs(old.current[0] - vec[0]) > eps || Math.abs(old.current[1] - vec[1]) > eps) {
        el.style.display = !isObjectBehindCamera(group.current, camera) ? 'block' : 'none';
        var scale = scaleFactor === undefined ? 1 : objectScale(group.current, camera) * scaleFactor;
        el.style.transform = "translate3d(" + vec[0] + "px," + vec[1] + "px,0) scale(" + scale + ")";
        el.style.zIndex = "" + objectZIndex(group.current, camera, zIndexRange);
      }

      old.current = vec;
    }
  });
  return /*#__PURE__*/React__default.createElement("group", _extends({}, props, {
    ref: group
  }));
});
var HTML = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
  React.useEffect(function () {
    return void console.warn('The <HTML> component was renamed to <Html>');
  }, []);
  return /*#__PURE__*/React__default.createElement(Html, _extends({}, props, {
    ref: ref
  }));
});

var Shadow = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$fog = _ref.fog,
      fog = _ref$fog === void 0 ? false : _ref$fog,
      _ref$colorStop = _ref.colorStop,
      colorStop = _ref$colorStop === void 0 ? 0.0 : _ref$colorStop,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? 'black' : _ref$color,
      _ref$opacity = _ref.opacity,
      opacity = _ref$opacity === void 0 ? 0.5 : _ref$opacity,
      props = _objectWithoutPropertiesLoose(_ref, ["fog", "colorStop", "color", "opacity"]);

  var canvas = React.useMemo(function () {
    var canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    var context = canvas.getContext('2d');
    var gradient = context.createRadialGradient(canvas.width / 2, canvas.height / 2, 0, canvas.width / 2, canvas.height / 2, canvas.width / 2);
    gradient.addColorStop(colorStop, new THREE.Color(color).getStyle());
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    context.fillStyle = gradient;
    context.fillRect(0, 0, canvas.width, canvas.height);
    return canvas;
  }, [color, stop]);
  return /*#__PURE__*/React__default.createElement("mesh", _extends({
    ref: ref
  }, props), /*#__PURE__*/React__default.createElement("planeBufferGeometry", {
    attach: "geometry",
    args: [1, 1]
  }), /*#__PURE__*/React__default.createElement("meshBasicMaterial", {
    attach: "material",
    transparent: true,
    opacity: opacity,
    fog: fog
  }, /*#__PURE__*/React__default.createElement("canvasTexture", {
    attach: "map",
    args: [canvas]
  })));
});

function Stats(_ref) {
  var _ref$showPanel = _ref.showPanel,
      showPanel = _ref$showPanel === void 0 ? 0 : _ref$showPanel,
      className = _ref.className,
      parent = _ref.parent;

  var _useState = React.useState(function () {
    return new StatsImpl();
  }),
      stats = _useState[0];

  React.useEffect(function () {
    var node = parent && parent.current || document.body;
    stats.showPanel(showPanel);
    node == null ? void 0 : node.appendChild(stats.dom);
    if (className) stats.dom.classList.add(className);
    var begin = reactThreeFiber.addEffect(function () {
      return stats.begin();
    });
    var end = reactThreeFiber.addAfterEffect(function () {
      return stats.end();
    });
    return function () {
      node == null ? void 0 : node.removeChild(stats.dom);
      begin();
      end();
    };
  }, [parent]);
  return null;
}

var WobbleMaterialImpl = /*#__PURE__*/function (_MeshStandardMaterial) {
  _inheritsLoose(WobbleMaterialImpl, _MeshStandardMaterial);

  function WobbleMaterialImpl(parameters) {
    var _this;

    _this = _MeshStandardMaterial.call(this, parameters) || this;

    _defineProperty(_assertThisInitialized(_this), "_time", void 0);

    _defineProperty(_assertThisInitialized(_this), "_factor", void 0);

    _this.setValues(parameters);

    _this._time = {
      value: 0
    };
    _this._factor = {
      value: 1
    };
    return _this;
  }

  var _proto = WobbleMaterialImpl.prototype;

  _proto.onBeforeCompile = function onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.factor = this._factor;
    shader.vertexShader = "\n      uniform float time;\n      uniform float factor;\n      " + shader.vertexShader + "\n    ";
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "float theta = sin( time + position.y ) / 2.0 * factor;\n        float c = cos( theta );\n        float s = sin( theta );\n        mat3 m = mat3( c, 0, s, 0, 1, 0, -s, 0, c );\n        vec3 transformed = vec3( position ) * m;\n        vNormal = vNormal * m;");
  };

  _createClass(WobbleMaterialImpl, [{
    key: "time",
    get: function get() {
      return this._time.value;
    },
    set: function set(v) {
      this._time.value = v;
    }
  }, {
    key: "factor",
    get: function get() {
      return this._factor.value;
    },
    set: function set(v) {
      this._factor.value = v;
    }
  }]);

  return WobbleMaterialImpl;
}(THREE.MeshStandardMaterial);

reactThreeFiber.extend({
  WobbleMaterialImpl: WobbleMaterialImpl
});
var MeshWobbleMaterial = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$speed = _ref.speed,
      speed = _ref$speed === void 0 ? 1 : _ref$speed,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  var material = React.useRef();
  reactThreeFiber.useFrame(function (state) {
    return material.current && (material.current.time = state.clock.getElapsedTime() * speed);
  });
  return /*#__PURE__*/React__default.createElement("wobbleMaterialImpl", _extends({
    ref: mergeRefs([ref, material]),
    attach: "material"
  }, props));
});

var distort = "#define GLSLIFY 1\nvec3 mod289(vec3 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}vec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}vec4 taylorInvSqrt(vec4 r){return 1.79284291400159-0.85373472095314*r;}float snoise(vec3 v){const vec2 C=vec2(1.0/6.0,1.0/3.0);const vec4 D=vec4(0.0,0.5,1.0,2.0);vec3 i=floor(v+dot(v,C.yyy));vec3 x0=v-i+dot(i,C.xxx);vec3 g=step(x0.yzx,x0.xyz);vec3 l=1.0-g;vec3 i1=min(g.xyz,l.zxy);vec3 i2=max(g.xyz,l.zxy);vec3 x1=x0-i1+C.xxx;vec3 x2=x0-i2+C.yyy;vec3 x3=x0-D.yyy;i=mod289(i);vec4 p=permute(permute(permute(i.z+vec4(0.0,i1.z,i2.z,1.0))+i.y+vec4(0.0,i1.y,i2.y,1.0))+i.x+vec4(0.0,i1.x,i2.x,1.0));float n_=0.142857142857;vec3 ns=n_*D.wyz-D.xzx;vec4 j=p-49.0*floor(p*ns.z*ns.z);vec4 x_=floor(j*ns.z);vec4 y_=floor(j-7.0*x_);vec4 x=x_*ns.x+ns.yyyy;vec4 y=y_*ns.x+ns.yyyy;vec4 h=1.0-abs(x)-abs(y);vec4 b0=vec4(x.xy,y.xy);vec4 b1=vec4(x.zw,y.zw);vec4 s0=floor(b0)*2.0+1.0;vec4 s1=floor(b1)*2.0+1.0;vec4 sh=-step(h,vec4(0.0));vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww;vec3 p0=vec3(a0.xy,h.x);vec3 p1=vec3(a0.zw,h.y);vec3 p2=vec3(a1.xy,h.z);vec3 p3=vec3(a1.zw,h.w);vec4 norm=taylorInvSqrt(vec4(dot(p0,p0),dot(p1,p1),dot(p2,p2),dot(p3,p3)));p0*=norm.x;p1*=norm.y;p2*=norm.z;p3*=norm.w;vec4 m=max(0.6-vec4(dot(x0,x0),dot(x1,x1),dot(x2,x2),dot(x3,x3)),0.0);m=m*m;return 42.0*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}"; // eslint-disable-line

var DistortMaterialImpl = /*#__PURE__*/function (_MeshPhysicalMaterial) {
  _inheritsLoose(DistortMaterialImpl, _MeshPhysicalMaterial);

  function DistortMaterialImpl(parameters) {
    var _this;

    _this = _MeshPhysicalMaterial.call(this, parameters) || this;

    _defineProperty(_assertThisInitialized(_this), "_time", void 0);

    _defineProperty(_assertThisInitialized(_this), "_distort", void 0);

    _defineProperty(_assertThisInitialized(_this), "_radius", void 0);

    _this.setValues(parameters);

    _this._time = {
      value: 0
    };
    _this._distort = {
      value: 0.4
    };
    _this._radius = {
      value: 1
    };
    return _this;
  }

  var _proto = DistortMaterialImpl.prototype;

  _proto.onBeforeCompile = function onBeforeCompile(shader) {
    shader.uniforms.time = this._time;
    shader.uniforms.radius = this._radius;
    shader.uniforms.distort = this._distort;
    shader.vertexShader = "\n      uniform float time;\n      uniform float radius;\n      uniform float distort;\n      " + distort + "\n      " + shader.vertexShader + "\n    ";
    shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', "\n        float updateTime = time / 50.0;\n        float noise = snoise(vec3(position / 2.0 + updateTime * 5.0));\n        vec3 transformed = vec3(position * (noise * pow(distort, 2.0) + radius));\n        ");
  };

  _createClass(DistortMaterialImpl, [{
    key: "time",
    get: function get() {
      return this._time.value;
    },
    set: function set(v) {
      this._time.value = v;
    }
  }, {
    key: "distort",
    get: function get() {
      return this._distort.value;
    },
    set: function set(v) {
      this._distort.value = v;
    }
  }, {
    key: "radius",
    get: function get() {
      return this._radius.value;
    },
    set: function set(v) {
      this._radius.value = v;
    }
  }]);

  return DistortMaterialImpl;
}(THREE.MeshPhysicalMaterial);

reactThreeFiber.extend({
  DistortMaterialImpl: DistortMaterialImpl
});
var MeshDistortMaterial = /*#__PURE__*/React__default.forwardRef(function (_ref, ref) {
  var _ref$speed = _ref.speed,
      speed = _ref$speed === void 0 ? 1 : _ref$speed,
      props = _objectWithoutPropertiesLoose(_ref, ["speed"]);

  var material = React.useRef();
  reactThreeFiber.useFrame(function (state) {
    return material.current && (material.current.time = state.clock.getElapsedTime() * speed);
  });
  return /*#__PURE__*/React__default.createElement("distortMaterialImpl", _extends({
    ref: mergeRefs([ref, material]),
    attach: "material"
  }, props));
});

reactThreeFiber.extend({
  SkyImpl: Sky$1.Sky
});
var Sky = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? 450000 : _ref$distance,
      _ref$sunPosition = _ref.sunPosition,
      sunPosition = _ref$sunPosition === void 0 ? [0, 1, 0] : _ref$sunPosition,
      props = _objectWithoutPropertiesLoose(_ref, ["distance", "sunPosition"]);

  var scale = React.useMemo(function () {
    return new THREE.Vector3().setScalar(distance);
  }, [distance]);
  return /*#__PURE__*/React__default.createElement("skyImpl", _extends({
    ref: ref,
    "material-uniforms-sunPosition-value": sunPosition,
    scale: scale
  }, props));
});

reactThreeFiber.extend({
  ReflectorImpl: Reflector$1.Reflector
});
var Reflector = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var children = _ref.children,
      color = _ref.color,
      textureWidth = _ref.textureWidth,
      textureHeight = _ref.textureHeight,
      clipBias = _ref.clipBias,
      shader = _ref.shader,
      encoding = _ref.encoding,
      props = _objectWithoutPropertiesLoose(_ref, ["children", "color", "textureWidth", "textureHeight", "clipBias", "shader", "encoding"]);

  return /*#__PURE__*/React__default.createElement("reflectorImpl", _extends({
    ref: ref,
    args: [undefined, {
      color: color,
      textureWidth: textureWidth,
      textureHeight: textureHeight,
      clipBias: clipBias,
      shader: shader,
      encoding: encoding
    }]
  }, props), React__default.Children.only(children));
});

reactThreeFiber.extend({
  Line2: Line2.Line2,
  LineGeometry: LineGeometry.LineGeometry,
  LineMaterial: LineMaterial.LineMaterial
});
var Line = /*#__PURE__*/React__default.forwardRef(function Line(_ref, ref) {
  var points = _ref.points,
      _ref$color = _ref.color,
      color = _ref$color === void 0 ? 'black' : _ref$color,
      vertexColors = _ref.vertexColors,
      rest = _objectWithoutPropertiesLoose(_ref, ["points", "color", "vertexColors"]);

  var lineRef = React.useRef();
  var geomRef = React.useRef();
  var resolution = React.useMemo(function () {
    return new THREE.Vector2(512, 512);
  }, []);
  React.useEffect(function () {
    if (!geomRef.current || !lineRef.current) return;
    geomRef.current.setPositions(points.flat());
    if (vertexColors) geomRef.current.setColors(vertexColors.flat());
    lineRef.current.computeLineDistances();
  }, [points, vertexColors]);
  return /*#__PURE__*/React__default.createElement("line2", _extends({
    ref: mergeRefs([lineRef, ref])
  }, rest), /*#__PURE__*/React__default.createElement("lineGeometry", {
    attach: "geometry",
    ref: geomRef
  }), /*#__PURE__*/React__default.createElement("lineMaterial", _extends({
    attach: "material",
    color: color,
    vertexColors: Boolean(vertexColors),
    resolution: resolution
  }, rest)));
});

var StarfieldMaterial = /*#__PURE__*/function (_ShaderMaterial) {
  _inheritsLoose(StarfieldMaterial, _ShaderMaterial);

  function StarfieldMaterial() {
    return _ShaderMaterial.call(this, {
      uniforms: {
        time: {
          value: 0.0
        },
        fade: {
          value: 1.0
        }
      },
      vertexShader: "uniform float time;\n      attribute float size;\n      varying vec3 vColor;\n      void main() {\n        vColor = color;\n        vec4 mvPosition = modelViewMatrix * vec4(position, 0.5);\n        gl_PointSize = size * (30.0 / -mvPosition.z) * (3.0 + sin(mvPosition.x + 2.0 * time + 100.0));\n        gl_Position = projectionMatrix * mvPosition;\n      }",
      fragmentShader: "uniform sampler2D pointTexture;\n      uniform float fade;\n      varying vec3 vColor;\n      void main() {\n        float opacity = 1.0;\n        if (fade == 1.0) {\n          float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n          opacity = 1.0 / (1.0 + exp(16.0 * (d - 0.25)));\n        }\n        gl_FragColor = vec4(vColor, opacity);\n      }"
    }) || this;
  }

  return StarfieldMaterial;
}(THREE.ShaderMaterial);

reactThreeFiber.extend({
  StarfieldMaterial: StarfieldMaterial
});

var genStar = function genStar(r) {
  return new THREE.Vector3().setFromSpherical(new THREE.Spherical(r, Math.acos(1 - Math.random() * 2), Math.random() * 2 * Math.PI));
};

var Stars = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var _ref$radius = _ref.radius,
      radius = _ref$radius === void 0 ? 100 : _ref$radius,
      _ref$depth = _ref.depth,
      depth = _ref$depth === void 0 ? 50 : _ref$depth,
      _ref$count = _ref.count,
      count = _ref$count === void 0 ? 5000 : _ref$count,
      _ref$saturation = _ref.saturation,
      saturation = _ref$saturation === void 0 ? 0 : _ref$saturation,
      _ref$factor = _ref.factor,
      factor = _ref$factor === void 0 ? 4 : _ref$factor,
      _ref$fade = _ref.fade,
      fade = _ref$fade === void 0 ? false : _ref$fade;
  var material = React.useRef();

  var _useMemo = React.useMemo(function () {
    var positions = [];
    var colors = [];
    var sizes = Array.from({
      length: count
    }, function () {
      return (0.5 + 0.5 * Math.random()) * factor;
    });
    var color = new THREE.Color();
    var r = radius + depth;
    var increment = depth / count;

    for (var i = 0; i < count; i++) {
      r -= increment * Math.random();
      positions.push.apply(positions, genStar(r).toArray());
      color.setHSL(i / count, saturation, 0.9);
      colors.push(color.r, color.g, color.b);
    }

    return [new Float32Array(positions), new Float32Array(colors), new Float32Array(sizes)];
  }, []),
      position = _useMemo[0],
      color = _useMemo[1],
      size = _useMemo[2];

  reactThreeFiber.useFrame(function (state) {
    return material.current && (material.current.uniforms.time.value = state.clock.getElapsedTime());
  });
  return /*#__PURE__*/React__default.createElement("points", {
    ref: ref
  }, /*#__PURE__*/React__default.createElement("bufferGeometry", {
    attach: "geometry"
  }, /*#__PURE__*/React__default.createElement("bufferAttribute", {
    attachObject: ['attributes', 'position'],
    args: [position, 3]
  }), /*#__PURE__*/React__default.createElement("bufferAttribute", {
    attachObject: ['attributes', 'color'],
    args: [color, 3]
  }), /*#__PURE__*/React__default.createElement("bufferAttribute", {
    attachObject: ['attributes', 'size'],
    args: [size, 1]
  })), /*#__PURE__*/React__default.createElement("starfieldMaterial", {
    ref: material,
    attach: "material",
    blending: THREE.AdditiveBlending,
    "uniforms-fade-value": fade,
    transparent: true,
    vertexColors: true
  }));
});

function draco(url) {
  if (url === void 0) {
    url = '/draco-gltf/';
  }

  return function (loader) {
    var dracoLoader = new DRACOLoader.DRACOLoader();
    dracoLoader.setDecoderPath(url);
    loader.setDRACOLoader(dracoLoader);
  };
}

var pcss = function pcss(_temp) {
  var _ref = _temp === void 0 ? {} : _temp,
      _ref$frustrum = _ref.frustrum,
      frustrum = _ref$frustrum === void 0 ? 3.75 : _ref$frustrum,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 0.005 : _ref$size,
      _ref$near = _ref.near,
      near = _ref$near === void 0 ? 9.5 : _ref$near,
      _ref$samples = _ref.samples,
      samples = _ref$samples === void 0 ? 17 : _ref$samples,
      _ref$rings = _ref.rings,
      rings = _ref$rings === void 0 ? 11 : _ref$rings;

  return "#define LIGHT_WORLD_SIZE " + size + "\n#define LIGHT_FRUSTUM_WIDTH " + frustrum + "\n#define LIGHT_SIZE_UV (LIGHT_WORLD_SIZE / LIGHT_FRUSTUM_WIDTH)\n#define NEAR_PLANE " + near + "\n\n#define NUM_SAMPLES " + samples + "\n#define NUM_RINGS " + rings + "\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n#define PCF_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples(const in vec2 randomSeed) {\n\tfloat ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n\tfloat INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n\tfloat angle = rand(randomSeed) * PI2;\n\tfloat radius = INV_NUM_SAMPLES;\n\tfloat radiusStep = radius;\n\tfor (int i = 0; i < NUM_SAMPLES; i++) {\n\t\tpoissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n\t\tradius += radiusStep;\n\t\tangle += ANGLE_STEP;\n\t}\n}\n\nfloat penumbraSize(const in float zReceiver, const in float zBlocker) { // Parallel plane estimation\n\treturn (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver) {\n\tfloat searchRadius = LIGHT_SIZE_UV * (zReceiver - NEAR_PLANE) / zReceiver;\n\tfloat blockerDepthSum = 0.0;\n\tint numBlockers = 0;\n\tfor (int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++) {\n\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n\t\tif (shadowMapDepth < zReceiver) {\n\t\t\tblockerDepthSum += shadowMapDepth;\n\t\t\tnumBlockers++;\n\t\t}\n\t}\n\tif (numBlockers == 0) return -1.0;\n\treturn blockerDepthSum / float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n\tfloat sum = 0.0;\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[ i ] * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\tfor (int i = 0; i < PCF_NUM_SAMPLES; i++) {\n\t\tfloat depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[ i ].yx * filterRadius));\n\t\tif (zReceiver <= depth) sum += 1.0;\n\t}\n\treturn sum / (2.0 * float(PCF_NUM_SAMPLES));\n}\n\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\n\tvec2 uv = coords.xy;\n\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\n\tinitPoissonSamples(uv);\n\tfloat avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n\tif (avgBlockerDepth == -1.0) return 1.0;\n\tfloat penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\treturn PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}";
};

var deployed = false;
var softShadows = function softShadows(props) {
  // Avoid adding the effect twice, which may happen in HMR scenarios
  if (!deployed) {
    deployed = true;
    var shader = THREE.ShaderChunk.shadowmap_pars_fragment;
    shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP\n' + pcss(_extends({}, props)));
    shader = shader.replace('#if defined( SHADOWMAP_TYPE_PCF )', '\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )');
    THREE.ShaderChunk.shadowmap_pars_fragment = shader;
  }
};

var _inverseMatrix = new THREE.Matrix4();

var _ray = new THREE.Ray();

var _sphere = new THREE.Sphere();

var _vA = new THREE.Vector3();

function meshBounds(raycaster, intersects) {
  var geometry = this.geometry;
  var material = this.material;
  var matrixWorld = this.matrixWorld;
  if (material === undefined) return; // Checking boundingSphere distance to ray

  if (geometry.boundingSphere === null) geometry.computeBoundingSphere();

  _sphere.copy(geometry.boundingSphere);

  _sphere.applyMatrix4(matrixWorld);

  if (raycaster.ray.intersectsSphere(_sphere) === false) return;

  _inverseMatrix.getInverse(matrixWorld);

  _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix); // Check boundingBox before continuing


  if (geometry.boundingBox !== null && _ray.intersectBox(geometry.boundingBox, _vA) === null) return;
  intersects.push({
    distance: _vA.distanceTo(raycaster.ray.origin),
    point: _vA.clone(),
    object: this
  });
}

function shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {
  return /*#__PURE__*/function (_THREE$ShaderMaterial) {
    _inheritsLoose(_class, _THREE$ShaderMaterial);

    function _class() {
      var _this2;

      var entries = Object.entries(uniforms); // Create unforms and shaders

      _this2 = _THREE$ShaderMaterial.call(this, {
        uniforms: entries.reduce(function (acc, _ref) {
          var _extends2;

          var name = _ref[0],
              value = _ref[1];
          return _extends({}, acc, (_extends2 = {}, _extends2[name] = {
            value: value
          }, _extends2));
        }, {}),
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      }) || this; // Create getter/setters

      entries.forEach(function (_ref2) {
        var name = _ref2[0];
        return Object.defineProperty(_assertThisInitialized(_this2), name, {
          get: function get() {
            return _this2.uniforms[name].value;
          },
          set: function set(v) {
            return _this2.uniforms[name].value = v;
          }
        });
      });
      if (onInit) onInit(_assertThisInitialized(_this2));
      return _this2;
    }

    return _class;
  }(THREE.ShaderMaterial);
}

function useCamera(camera, props) {
  var _useThree = reactThreeFiber.useThree(),
      mouse = _useThree.mouse;

  var _useState = React.useState(function () {
    var raycaster = new THREE.Raycaster();
    if (props) reactThreeFiber.applyProps(raycaster, props, {});
    return function (_, intersects) {
      raycaster.setFromCamera(mouse, camera instanceof THREE.Camera ? camera : camera.current);
      var rc = this.constructor.prototype.raycast.bind(this);
      if (rc) rc(raycaster, intersects);
    };
  }),
      raycast = _useState[0];

  return raycast;
}

function useHelper(object3D, proto) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  var helper = React__default.useRef();

  var _useThree = reactThreeFiber.useThree(),
      scene = _useThree.scene;

  React.useEffect(function () {
    if (proto && object3D.current) {
      helper.current = _construct(proto, [object3D.current].concat(args));

      if (helper.current) {
        scene.add(helper.current);
      }
    }

    return function () {
      if (helper.current) {
        scene.remove(helper.current);
      }
    };
  }, [scene, proto, object3D, args]);
  reactThreeFiber.useFrame(function () {
    if (helper.current) {
      helper.current.update();
    }
  });
  return helper;
}

function useAspect(type, width, height, factor) {
  if (factor === void 0) {
    factor = 1;
  }

  var _useThree = reactThreeFiber.useThree(),
      v = _useThree.viewport,
      aspect = _useThree.aspect;

  var adaptedHeight = height * (aspect > width / height ? v.width / width : v.height / height);
  var adaptedWidth = width * (aspect > width / height ? v.width / width : v.height / height);
  return [adaptedWidth * factor, adaptedHeight * factor, 1];
}

function create(type) {
  var El = type + 'BufferGeometry';
  return /*#__PURE__*/React.forwardRef(function (_ref, ref) {
    var args = _ref.args,
        children = _ref.children,
        props = _objectWithoutPropertiesLoose(_ref, ["args", "children"]);

    return /*#__PURE__*/React__default.createElement("mesh", _extends({
      ref: ref
    }, props), /*#__PURE__*/React__default.createElement(El, {
      attach: "geometry",
      args: args
    }), children);
  });
}

var Box = create('box');
var Circle = create('circle');
var Cone = create('cone');
var Cylinder = create('cylinder');
var Sphere = create('sphere');
var Plane = create('plane');
var Tube = create('tube');
var Torus = create('torus');
var TorusKnot = create('torusKnot');
var Tetrahedron = create('tetrahedron');
var Ring = create('ring');
var Polyhedron = create('polyhedron');
var Icosahedron = create('icosahedron');
var Octahedron = create('octahedron');
var Dodecahedron = create('dodecahedron');
var Extrude = create('extrude');
var Lathe = create('lathe');
var Parametric = create('parametric');

function useTextureLoader(url) {
  return reactThreeFiber.useLoader(THREE.TextureLoader, url);
}

function useGLTFLoader(path, useDraco) {
  var gltf = reactThreeFiber.useLoader(GLTFLoader.GLTFLoader, path, useDraco ? draco(typeof useDraco === 'string' ? useDraco : '/draco-gltf/') : undefined);
  return gltf;
}

function useCubeTextureLoader(files, _ref) {
  var path = _ref.path;

  // @ts-ignore
  var _useLoader = reactThreeFiber.useLoader( // @ts-ignore
  THREE.CubeTextureLoader, [files], function (loader) {
    return loader.setPath(path);
  }),
      cubeTexture = _useLoader[0];

  return cubeTexture;
}

exports.Box = Box;
exports.Circle = Circle;
exports.Cone = Cone;
exports.Cylinder = Cylinder;
exports.Detailed = Detailed;
exports.DeviceOrientationControls = DeviceOrientationControls;
exports.Dodecahedron = Dodecahedron;
exports.Extrude = Extrude;
exports.FlyControls = FlyControls;
exports.HTML = HTML;
exports.Html = Html;
exports.Icosahedron = Icosahedron;
exports.Lathe = Lathe;
exports.Line = Line;
exports.MapControls = MapControls;
exports.MeshDistortMaterial = MeshDistortMaterial;
exports.MeshWobbleMaterial = MeshWobbleMaterial;
exports.Octahedron = Octahedron;
exports.OrbitControls = OrbitControls;
exports.OrthographicCamera = OrthographicCamera;
exports.Parametric = Parametric;
exports.PerspectiveCamera = PerspectiveCamera;
exports.Plane = Plane;
exports.Polyhedron = Polyhedron;
exports.PositionalAudio = PositionalAudio;
exports.Reflector = Reflector;
exports.Ring = Ring;
exports.Shadow = Shadow;
exports.Sky = Sky;
exports.Sphere = Sphere;
exports.StandardEffects = StandardEffects;
exports.Stars = Stars;
exports.Stats = Stats;
exports.Tetrahedron = Tetrahedron;
exports.Text = Text;
exports.Torus = Torus;
exports.TorusKnot = TorusKnot;
exports.TrackballControls = TrackballControls;
exports.TransformControls = TransformControls;
exports.Tube = Tube;
exports.draco = draco;
exports.meshBounds = meshBounds;
exports.shaderMaterial = shaderMaterial;
exports.softShadows = softShadows;
exports.useAspect = useAspect;
exports.useCamera = useCamera;
exports.useCubeTextureLoader = useCubeTextureLoader;
exports.useGLTFLoader = useGLTFLoader;
exports.useHelper = useHelper;
exports.useTextureLoader = useTextureLoader;
